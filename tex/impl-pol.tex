\section{Implementierung von Polynomen}

\subsection{Der Datentyp}

Grundsätzlich gibt es zwei verschiedene Möglichkeiten Polynome zu
implementieren: \emph{sparse} und \emph{dense}, d.h. 
\begin{itemize}
  \item entweder entscheidet man
    sich ein Polynom $f(X) = a_nX^n + \ldots + a_0$ als Liste\footnote{Was genau 
    eine ``Liste'' in der jeweilig benutzten Sprache bedeuten soll, bleibt der
    Interpretation überlassen.} der Länge $n$ zu hinterlegen,
  \item oder man speichert lediglich eine Liste von Tupel $(i,a_i)$, so dass
    $i \in \{0,\ldots,n\}$ den Index/Exponenten des Koeffizienten $a_i$ angibt
    und alle Koeffizienten, die Null sind, ausgelassen werden.
\end{itemize}
In der hier vorliegenden finalen implementierung haben wir uns für letztere
Variante entschieden, da diese insbesondere bei spärlich besetzten Polynomen
mit hohem Grad deutliche Performancegewinne zeigt.

Konkret ist ein Polynom also definiert durch:
\haskellinput{Core/Polynomials}{data Polynom}

Um diese Darstellung \emph{dense} nennen und mit ihr effizient arbeiten zu 
können, treffen wir folgende Beschränkungen an die Implementierung:
\begin{invariante}
  \label{inv:poly}
  Für ħPMS $L$ Trueħ gilt stets, dass die Monome in $L$ alle nicht Null 
  sind und ihrem Grade nach in
  absteigender Reihenfolge sortiert sind, d.h.
  \begin{enumerate}
    \item für alle $(i,x) \in L$ ist $x \neq 0$.
    \item für alle $(i,x), (j,y) \in L$ gilt: Steht $(i,x)$ vor $(j,y)$, so ist
      $i > j$.
  \end{enumerate}
  Ein Polynom, das diese Eigenschaften erfüllt, wollen wir auch 
  \emph{wohlgeformt} oder \emph{korrekt dargestellt} nennen.
\end{invariante}

\begin{beispiel}
  Für das Polynom $f(X) = X^5 + 3X^2 + 1$ wäre 
  \begin{hcode}
    PMS [(5,1), (2,3), (0,1)] True
  \end{hcode}
  die korrekte Darstellung.
\end{beispiel}

Damit diese Invariante stets sichergestellt ist, existiert die Funktion
ħcleanPħ, mit der eine ħ[(Int,a)]ħ Liste in die korrekte Form gebracht werden
kann:
\haskellinput{Core/Polynomials}{cleanP}


\subsubsection{Polynome erstellen}
\paragraph{Allgemein}
Diese Einschränkung erfordert auch, dass der Konstruktor des Polynomdatentyps
nicht öffentlich gemacht wird und wir benötigen separate Funktionen, um
Polynome zu erstellen. Diese sind selbsterklärend:
\haskellinput{Core/Polynomials}{pList}
\haskellinput{Core/Polynomials}{pTup}
Ferner existiert noch eine Variante der ``unsicheren'' Erstellung von
Polynomen, die eine korrekte Darstellung nach \thref{inv:poly} voraussetzt,
diese jedoch nicht prüft. 
\haskellinput{Core/Polynomials}{pTupUnsave}


\paragraph{Polynome dekonstruieren}
Den Weg rückwärts zu gehen ist natürlich auch möglich, was ħp2Tupħ und ħp2Listħ
bewerkstelligen:

\haskellinput{Core/Polynomials}{p2Tup}
\haskellinput{Core/Polynomials}{p2List}


\paragraph{Spezielle Polynome}
Eines der am häufigsten verwendenten Polynome ist das Nullpolynom. Daher gibt
es sowohl eine Prüfung, ob ein Polynom null ist, als auch das Nullpolynom
selbst als Objekt:
\haskellinput{Core/Polynomials}{nullP}
\haskellinput{Core/Polynomials}{isNullP}


Des Weiteren haben wir eine kleine Schreibhilfe zur Erstellung von konstanten
Polynomen generiert:
\haskellinput{Core/Polynomials}{pKonst}



\subsection{Zweiwertige Operationen auf Polynomen}
\paragraph{Gleichheit} Bekanntlich sind zwei Polynome 
genau dann gleich, wenn ihre Koeffizienten übereinstimmen:
\haskellinput{Core/Polynomials}{eqP}

\paragraph{Addition} Hier kommt zum ersten mal ein kleiner Nachteil der
\emph{dense} Darstellung zu Tage, da das Addieren zweier Polynome nicht einfach
das elementweise summieren zweier Listen ist, sondern stets geprüft werden
muss, bei welchem Grad man gerade ist:
\haskellinput{Core/Polynomials}{addPM}
ħaddPMħ darf offensichtlich nur ausgeführt werden, wenn die beiden Polynome
\thref{inv:poly} erfüllen. Darüber hinaus stellt obige Funktion auch sicher,
dass besagte Invariante erhalten bleibt.

\paragraph{Subtraktion} Da die funktionale Programmierung lediglich 
nicht veränderbare Objekte (\emph{immutable Objects}) vorsieht, würde durch die
Standarddefinition der Subtraktion, nämlich Addition des ersten mit dem
negierten zweiten Argument, das zweite Polynom doppelt durchlaufen (einmal beim
Negieren und einmal beim Addieren) werden. Um dies zu verhindern, haben wir die
Subtraktion separat geschrieben.
\haskellinput{Core/Polynomials}{subtrPM}
Wiederum darf obige Subtraktion nur auf wohlgeformte Polynome angewandt werden.



% vim:set ft=tex foldmethod=marker foldmarker={{{,}}}:
