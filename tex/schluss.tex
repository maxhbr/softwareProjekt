In den vorherigen Kapiteln konnten wir die Umsetzung einer Bibliothek von
Grundfunktionen auf endlichen Körpern in Haskell erläutern und demonstrieren.
Sicherlich sind die bisher implementierten Funktionen bei weitem nicht
ausreichend, um dieses Library als vollständig bezeichnen zu können. So ist
klar, dass die meisten Computer-Algebra-Systeme, was den Funktionsumfang
endlicher Körper betrifft, unserem kleinen Softwareprojekt überlegen
sind. Es gilt jedoch zu bemerken, dass wir gerade auf den Funktionsumfang für 
Polynome über endlichen Körpern, insbesondere was verschiedene
Multiplikations- und Faktorisierungsalgorithmen angeht, besonderes Augenmerk
gelegt haben.

\addsec{Wie könnte es weitergehen?}
Statt einer Schlussbemerkung drängt sich daher sicherlich die Frage nach einer
Fortsetzung des Projekts auf.

\paragraph{Erweiterung des Funktionsumfangs} Das Hinzufügen neuer
Funktionen könnte das Projekt fortsetzen. 
Bekanntlich existieren gerade für endliche Körper der Charakteristik 2 
spezielle Algorithmen, die weitaus effizienter sind, als ihre Pendents in
allgemeiner Charakteristik. Aus hauptsächlich
mathematisch interessierter Sicht ist dies vermutlich eine spannende
Aufgabe, da -- wie wir im Laufe des Projekts erkennen konnten -- die Syntax von
Haskell der Art und Weise mathematischer Notation besonders ähnlich ist.

\paragraph{Performance der Implementierung} Trotz der ,,Schönheit`` funktionaler
Programmierung mussten wir an vielen Stellen bemerken, dass das Konzept der
unveränderlichen Objekte auf Kosten der Performance geht. Insbesondere bei
großen Datenstrukturen, wie z.B. Polynomen über Körpererweiterungen (also
Polynome, deren Koeffizienten wiederum Polynome sind) oder auch Matrizen mit
polynomialen Einträgen, nimmt der \emph{garbage collector}, also dasjenige
Unterprogramm der Ausführung, das den Speicher nicht mehr benutzter Objekte
wieder frei gibt, einen großen, wenn nicht sogar den größten Teil der
Ausführungszeit ein. An diesem Punkt besteht sicherlich großes
Optimierungspotential. Ein Ansatz könnte es sein, an den berechnungsintensiven
Stellen von der Funktionalität abzuweichen und in \emph{Monaden}%
\footnote{Übrigens sind Monaden aus Sicht der Kategorientheorie sehr
interessante Objekte.}
(z.B. \autocite{haskellwiki:monaden}) zu wechseln. Alternativ könnte man
natürlich versuchen, \emph{mehr} statt weniger Funktionalität
zur Verbesserung der Laufzeit einzusetzen. Da, wie bereits öfters erwähnt,
Haskell Ausdrücke nicht auswertet, solange sie nicht de facto benötigt werden,
könnte man versuchen, die entstehenden \emph{Thunk}s 
(z.B. \autocite{haskellwiki:thunk}), also die noch nicht ausgewerteten Stellen,
zu vereinfachen. Beide Herangehensweisen sind sicherlich legitim, würden 
jedoch eine weitaus intensivere Einarbeitung in die tiefe Struktur von Haskell
erfordern und den Rahmen dieses Projekts sprengen. 

Obwohl an vielen Stellen sicherlich noch Optimierungspotential bezüglich der
Performance des Projekts besteht, möchten wir anmerken, dass Haskell im
Allgemeinen mindestens genauso schnell ist, wie andere Programmiersprachen.
(vgl. \autocite{haskellwiki:performance}) 

Nun möchten wir das Wort an 
Philip Greenspun und Autrijus Tang übergeben, um abschließend ein Gefühl für das
Programmieren in Haskell zu geben.

\begin{quote}
  \itshape SQL, Lisp, and Haskell are the only programming languages that 
  I've seen where one spends more time thinking than typing.
  \hfill\normalfont\sffamily\small Philip Greenspun%
  \footnote{%
  \url{http://blogs.law.harvard.edu/philg/2005/03/07/how-long-is-the-average-internet-discussion-forum-posting/}}
\end{quote}

\begin{quote}
  \itshape 
  Haskell is faster than C++, more concise than Perl, more regular than Python,
  more flexible than Ruby, more typeful than C\#, more robust than Java, and 
  has absolutely nothing in common with PHP.
  \hfill\normalfont\sffamily\small Autrijus Tang%
  \footnote{\url{http://www.perl.com/pub/2005/09/08/autrijus-tang.html?page=2}}
\end{quote}
